input {
  jdbc {
    type => "srms"
    jdbc_driver_library => "ifxjdbc.jar"
    jdbc_driver_class => "com.informix.jdbc.IfxDriver"
    jdbc_connection_string => "{{DB_CONNECTION}}"
    jdbc_user => "{{DB_USER}}"
    jdbc_password => "{{DB_PASSWORD}}"
    schedule => "*/5 * * * *"
    clean_run=>true
    statement => "SELECT
   contest.contest_id id,
   contest.contest_id _id,
   contest.NAME NAME,
   CASE
      WHEN
         (
            (registration_segment.start_time < sysdate) 
            AND 
            (system_test_segment.end_time > sysdate)
         )
      THEN
         'ACTIVE' 
      WHEN
         (registration_segment.start_time > sysdate)
      THEN
         'FUTURE' 
      WHEN
         (system_test_segment.end_time < sysdate)
      THEN
         'PAST' 
   END
   status, 
   contest.start_date startdate, 
   contest.end_date enddate, 
   'DATA SCIENCE' track, 
   'SRM' subtrack, 
   round.forum_id forumid, 
   (
      SELECT
         COUNT(*) 
      FROM
         INFORMIXOLTP:round_registration r 
      WHERE
         r.round_id = round.round_id 
   )
   numberofregistrants,
   round_registrations.coder_id userid,
   round.round_id roundid,
   registration_segment.start_time registrationstartat,
   registration_segment.end_time registrationendat,
   coding_segment.start_time codingstartat,
   coding_segment.end_time codingendat,
   system_test_segment.start_time systeststartat,
   system_test_segment.end_time systestendat,
   round_registrations.coder_id || room_result.rated_flag isratedforsrm 
FROM
   INFORMIXOLTP:contest AS contest 
   LEFT JOIN
      INFORMIXOLTP:round AS round 
      ON round.contest_id = contest.contest_id 
      AND round.round_type_id = 1 
   LEFT JOIN
      INFORMIXOLTP:round_registration AS round_registrations 
      ON round_registrations.round_id = round.round_id 
   LEFT JOIN
      TCS_CATALOG:user AS user_table 
      ON user_table.user_id = round_registrations.coder_id 
   LEFT JOIN
      INFORMIXOLTP:round_segment AS registration_segment 
      ON registration_segment.round_id = round.round_id 
      AND registration_segment.segment_id = 1 
   LEFT JOIN
      INFORMIXOLTP:round_segment AS coding_segment 
      ON coding_segment.round_id = round.round_id 
      AND coding_segment.segment_id = 2 
   LEFT JOIN
      INFORMIXOLTP:round_segment AS system_test_segment 
      ON system_test_segment.round_id = round.round_id 
      AND system_test_segment.segment_id = 5 
   LEFT JOIN
      INFORMIXOLTP:room_result AS room_result
      ON room_result.round_id = round.round_id 
      AND room_result.coder_id = round_registrations.coder_id"
  }
}

filter {
  if [type] == "srms" {
    mutate {
      convert => { "id" => "integer" }
      convert => { "roundid" => "integer" }
      convert => { "numberofregistrants" => "integer"}
      rename => { "startdate" => "startDate" }
      rename => { "enddate" => "endDate" }
      rename => { "subtrack" => "subTrack" }
      rename => { "forumid" => "forumId" }
      rename => { "numberofregistrants" => "numberOfRegistrants" }
      rename => { "roundid" => "roundId" }
      rename => { "registrationstartat" => "registrationStartAt" }
      rename => { "registrationendat" => "registrationEndAt" }
      rename => { "codingstartat" => "codingStartAt" }
      rename => { "codingendat" => "codingEndAt" }
      rename => { "systeststartat" => "systemTestStartAt" }
      rename => { "systestendat" => "systemTestEndAt" }
      remove_field => ["@version", "@timestamp", "_id"]
    }
    aggregate {
      task_id => "_%{id}"
      code => "map['userIds'] ||= Array.new;
                  if event['userid'] && !map['userIds'].include?(event['userid'])
                  map['userIds'].push(event['userid']);
               end
               event['userIds'] = map['userIds']"
      timeout => 40
    }
    mutate {
      remove_field => ["userid"]
    }

    aggregate {
      task_id => "_%{id}"
      code => "map['isRatedForSRM'] ||= Array.new;
                  if event['isratedforsrm'] && !map['isRatedForSRM'].include?(event['isratedforsrm'])
                  map['isRatedForSRM'].push(event['isratedforsrm']);
               end
               event['isRatedForSRM'] = map['isRatedForSRM']"
      timeout => 40
    }
    mutate {
      remove_field => ["isratedforsrm"]
    }
  }
}

output {
    amazon_es {
        hosts => ["{{AWS_HOST}}"]
        region => "{{AWS_REGION}}"
        aws_access_key_id => "{{AWS_ACCESS_KEY}}"
        aws_secret_access_key => "{{AWS_ACCESS_SECRET}}"
        index => "{{INDEX_NAME}}"
        document_type => "%{type}"
        document_id => "%{id}"
    }
    stdout { codec => rubydebug }
}
